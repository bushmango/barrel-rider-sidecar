#!/usr/bin/env node
import * as commandLineArgs from 'command-line-args'
import * as commandLineUsage from 'command-line-usage'
import * as fs from 'fs'
import { glob } from 'glob'
import * as watch from 'glob-watcher'
import * as l from 'lodash'
import * as path from 'path'
import { promisify } from 'util'

const globAsync = promisify(glob)
const unlinkAsync = promisify(fs.unlink)

console.log('The Barrel-Rider Sidecar Edition -- Create Typescript Index Files')

const cwd = process.cwd()
console.log('in ' + cwd)

// https://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') // $& means the whole matched string
}

const sections = [
  {
    header: 'The Barrel-Rider Sidecar Edition',
    content: 'Creates Typescript index files',
  },
  {
    header: 'Options',
    optionList: [
      {
        name: 'src',
        typeLabel: '{underline directories}',
        description: 'The directories to scan (globs).',
      },
      {
        name: 'watch',
        typeLabel: '{underline Boolean}',
        description:
          'Keep this process open and rebuild files when they change.',
      },
      {
        name: 'verbose',
        typeLabel: '{underline Boolean}',
        description: 'Show extra debug info.',
      },
      {
        name: 'quiet',
        typeLabel: '{underline Boolean}',
        description: 'Hide extra logging.',
      },
      {
        name: 'help',
        description: 'Print this usage guide.',
      },
      {
        name: 'remove',
        description: 'Remove old sidecar files.',
      },
    ],
  },
]

// import { promisify } from 'util'
// const readFileAsync = promisify(fs.readFile)
// const writeFileAsync = promisify(fs.writeFile)

async function removeIndexFile(_path) {
  let skip = false
  if (fs.existsSync(_path)) {
    let cur = fs.readFileSync(_path, 'utf8')
    if (cur.startsWith('// barrel-rider:ignore')) {
      skip = true
    }
  }
  if (!skip) {
    console.log('removing', _path)
    await unlinkAsync(_path)
  }
}

async function run() {
  const optionDefinitions = [
    { name: 'help', alias: 'h', type: Boolean },
    { name: 'verbose', alias: 'v', type: Boolean },
    {
      name: 'src',
      alias: 's',
      type: String,
      multiple: true,
      defaultOption: true,
    },
    { name: 'watch', alias: 'w', type: Boolean },
    { name: 'port', alias: 'p', type: Number },
    { name: 'remove', alias: 'r', type: Boolean },
  ]
  const options = commandLineArgs(optionDefinitions)

  let valid = options.help || (options.src && options.src.length)
  if (!options.watch) {
    console.log('Sorry, currently only works in watch mode!')
    valid = false
  }

  if (!valid || options.help) {
    // console.log('!! invalid options !!')
    const usage = commandLineUsage(sections)
    console.log(usage)
    return
  }

  l.defaults(options, { extension: 'ts' })

  if (options.verbose) {
    console.log('verbose mode')
    console.log('cwd:', cwd)
    console.log('options:', JSON.stringify(options, null, 2))
  }

  if (options.remove) {
    // Delete existing index.ts files
    console.log('deleting existing index files')

    for (let i = 0; i < options.src.length; i++) {
      let src = options.src[i]
      let files = await globAsync(src + '/**/*-sidecar.@(ts|tsx)')
      for (let f of files) {
        let ext = path.extname(f)
        let testFile =
          f.substring(0, f.length - '-sidecar'.length - ext.length) + ext
        if (!fs.existsSync(testFile)) {
          await removeIndexFile(f)
        }
      }
      files = await globAsync(src + '/**/*.sidecar.@(ts|tsx)')
      for (let f of files) {
        await removeIndexFile(f)
      }
    }
  }

  let indexesToRebuild: string[] = []

  function rebuildIndex(_path: string) {
    if (options.verbose) {
      console.log('trying path', _path)
    }
    if (
      _path.endsWith('index.ts') ||
      _path.endsWith('index.tsx') ||
      _path.includes('node_modules') ||
      _path.includes(' copy') // Renaming file, don't make an index for this
    ) {
      return // This shouldn't trigger rebuilding of indexes
    }
    if (!l.includes(indexesToRebuild, _path)) {
      indexesToRebuild.push(_path)
    }
    rebuildIndexesThrottled()
  }

  function rebuildIndexes() {
    // console.log('should build index', indexesToRebuild)
    let rebuiltCount = 0
    let skippedCount = 0
    let rebuiltPaths: string[] = []
    l.forEach(indexesToRebuild, (_path) => {
      if (options.verbose) {
        console.log('building barrel index for', _path)
      }

      let lines = []
      lines.push('/* eslint-disable */')
      lines.push('/* tslint:disable */')
      lines.push(
        '// THIS FILE IS AuTo-GeNeRaTeD BY barrel-rider-sidecar. DO NOT EDIT',
      )
      lines.push('// see: https://www.npmjs.com/package/barrel-rider-sidecar')
      // lines.push('export const noop = () => {}') // Always export something

      let f = _path

      let _toDelete = false
      let skip = false
      if (f.endsWith('-sidecar.ts') || f.endsWith('.sidecar.tsx')) {
        // Don't scan indexes
        _toDelete = true
      }
      if (f.endsWith('.d.ts')) {
        // Skip d.ts files
        _toDelete = true
      }
      if (
        f.indexOf('.spec.') !== -1 ||
        f.indexOf('.test.') !== -1 ||
        f.indexOf('.e2e.') !== -1
      ) {
        // Test files
        _toDelete = true
      }

      let ext = path.extname(_path)
      let pathWithoutExt = _path.slice(0, _path.length - ext.length)
      let sidecarFilename = pathWithoutExt + '-sidecar.' + options.extension

      if (!_toDelete) {
        let basename = path.basename(f)
        let last = basename.lastIndexOf('.')
        let filename = basename.substring(0, last)
        let exportAs = filename.replace(/\./, '_')

        if (doesFileHaveNamedExport(f, exportAs)) {
          // Named exports
          _toDelete = true
          // lines.push(`export * from './${filename}'`)
        } else {
          // Group and re-export
          lines.push(`import * as ${exportAs} from './${filename}'`)
          lines.push(`export { ${exportAs} }`)
        }

        // Write the file

        if (!_toDelete) {
          let newFileContents = lines.join('\n')
          if (fs.existsSync(sidecarFilename)) {
            let cur = fs.readFileSync(sidecarFilename, 'utf8')
            if (cur.startsWith('// barrel-rider:ignore')) {
              skip = true
            }
            if (cur.startsWith('// sidecar:ignore')) {
              skip = true
            }
            if (cur === newFileContents) {
              skip = true
              skippedCount++
            }
          }
          if (!skip) {
            rebuiltCount++
            fs.writeFileSync(sidecarFilename, newFileContents)
            rebuiltPaths.push(sidecarFilename)
          }
        }
      }

      if (_toDelete) {
        if (fs.existsSync(sidecarFilename)) {
          fs.unlinkSync(sidecarFilename)
        }
      }
    })

    if (!options.quiet) {
      if (rebuiltCount) {
        console.log(
          'barrel-rider rebuilt',
          rebuiltCount,
          'skipped',
          skippedCount,
        )
        if (rebuiltPaths.length === 1) {
          console.log(`(${rebuiltPaths[0]})`)
        }
      }
    }
    indexesToRebuild = [] // Reset
  }
  const rebuildIndexesThrottled = l.debounce(rebuildIndexes, 2000)

  function doesFileHaveNamedExport(_path, filename: string) {
    if (filename.indexOf('index') !== -1) {
      return false
    }

    let regex = new RegExp(
      `\\s*export\\s+(async\\s+)?(const|function|interface|type|class)\\s+(${escapeRegExp(
        filename,
      )})(\\s|\\()`,
    )
    // console.log(regex)
    let regex2 = new RegExp(
      `\\s*export\\s+{.*(\\s+|\\,)(${escapeRegExp(filename)})(\\s+|\\,|\\})`,
    )

    let f = fs.readFileSync(_path, { encoding: 'utf8' })

    return regex.test(f) || regex2.test(f)
  }

  const watchDirecories = []
  l.forEach(options.src, (c) => {
    if (options.watch) {
      const watchDirectory = path.join(cwd, c)
      //const watchDirectoryGlob = watchDirectory + '/**/*(.ts|.tsx)'
      let watchDirectoryGlob = path.join(watchDirectory, '/**/*.(ts|tsx)')

      if (/^win/.test(process.platform)) {
        watchDirectoryGlob = watchDirectoryGlob.replace(/\\/g, '/')
      }

      watchDirecories.push(watchDirectoryGlob)
      // rebuildIndex(watchDirectory)
      console.log('watching: ', watchDirectoryGlob)
      // if (options.verbose) {
      //   console.log('watching: ', watchDirectoryGlob)
      // }
    } else {
      // TODO work without watch mode
      // glob(c + '/*.@(ts|tsx)')
    }
  })
  if (options.watch) {
    let watcher = watch(watchDirecories, {
      ignoreInitial: false,
    })
    watcher.on('add', (_path: string, stat) => {
      rebuildIndex(_path)
    })
    watcher.on('change', (_path, stat) => {
      rebuildIndex(_path)
    })
    watcher.on('delete', (_path, stat) => {
      rebuildIndex(_path)
    })
  }

  function _watch() {
    console.log('watching')

    // Keep alive
    setInterval(() => {}, 1 << 30)
    // if (process.stdin.isTTY) {
    //   console.log('Press any key to exit')
    //   process.stdin.setRawMode(true)
    //   process.stdin.resume()
    //   process.stdin.on('data', process.exit.bind(process, 0))
    // }
  }

  if (options.watch) {
    _watch()
  }
}
run()

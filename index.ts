#!/usr/bin/env node
import * as bodyParser from 'body-parser'
import * as commandLineArgs from 'command-line-args'
import * as commandLineUsage from 'command-line-usage'
import * as cors from 'cors'
import * as express from 'express'
import * as fs from 'fs'
import { glob } from 'glob'
import * as watch from 'glob-watcher'
import * as l from 'lodash'
import * as path from 'path'
import { promisify } from 'util'

const globAsync = promisify(glob)
const unlinkAsync = promisify(fs.unlink)

console.log('The Barrel-Rider Sidecar Edition -- Create Typescript Index Files')

const cwd = process.cwd()
console.log('in ' + cwd)

const sections = [
  {
    header: 'The Barrel-Rider Sidecar Edition',
    content: 'Creates Typescript index files',
  },
  {
    header: 'Options',
    optionList: [
      {
        name: 'src',
        typeLabel: '{underline directories}',
        description: 'The directories to scan (globs).',
      },
      {
        name: 'watch',
        typeLabel: '{underline Boolean}',
        description:
          'Keep this process open and rebuild files when they change.',
      },
      {
        name: 'verbose',
        typeLabel: '{underline Boolean}',
        description: 'Show extra debug info.',
      },
      {
        name: 'quiet',
        typeLabel: '{underline Boolean}',
        description: 'Hide extra logging.',
      },
      {
        name: 'help',
        description: 'Print this usage guide.',
      },
    ],
  },
]

// import { promisify } from 'util'
// const readFileAsync = promisify(fs.readFile)
// const writeFileAsync = promisify(fs.writeFile)

async function removeIndexFile(_path) {
  let skip = false
  if (fs.existsSync(_path)) {
    let cur = fs.readFileSync(_path, 'utf8')
    if (cur.startsWith('// barrel-rider:ignore')) {
      skip = true
    }
  }
  if (!skip) {
    console.log('removing', _path)
    await unlinkAsync(_path)
  }
}

async function run() {
  const optionDefinitions = [
    { name: 'help', alias: 'h', type: Boolean },
    { name: 'verbose', alias: 'v', type: Boolean },
    {
      name: 'src',
      alias: 's',
      type: String,
      multiple: true,
      defaultOption: true,
    },
    { name: 'watch', alias: 'w', type: Boolean },
    { name: 'port', alias: 'p', type: Number },
    { name: 'remove', alias: 'r', type: Boolean },
  ]
  const options = commandLineArgs(optionDefinitions)

  let valid = options.help || (options.src && options.src.length)
  if (!options.watch) {
    console.log('Sorry, currently only works in watch mode!')
    valid = false
  }

  if (!valid || options.help) {
    // console.log('!! invalid options !!')
    const usage = commandLineUsage(sections)
    console.log(usage)
    return
  }

  l.defaults(options, { extension: 'ts' })

  if (options.verbose) {
    console.log('verbose mode')
    console.log('cwd:', cwd)
    console.log('options:', JSON.stringify(options, null, 2))
  }

  if (options.remove) {
    // Delete existing index.ts files
    console.log('deleting existing index files')
    let files = await globAsync(options.src + '/**/*-sidecar.@(ts|tsx)')
    for (let f of files) {
      await removeIndexFile(f)
    }
  }

  let indexesToRebuild: string[] = []

  function rebuildIndex(_path: string) {
    if (options.verbose) {
      console.log('trying path', _path)
    }
    if (
      _path.endsWith('index.ts') ||
      _path.endsWith('index.tsx') ||
      _path.includes('node_modules')
    ) {
      return // This shouldn't trigger rebuilding of indexes
    }
    if (!l.includes(indexesToRebuild, _path)) {
      indexesToRebuild.push(_path)
    }
    rebuildIndexesThrottled()
  }

  function rebuildIndexes() {
    // console.log('should build index', indexesToRebuild)
    let rebuiltCount = 0
    let skippedCount = 0
    let rebuiltPaths: string[] = []
    l.forEach(indexesToRebuild, (_path) => {
      if (options.verbose) {
        console.log('building barrel index for', _path)
      }

      let lines = []
      lines.push('// THIS FILE IS AUTOGENERATED. DO NOT EDIT')
      lines.push('/* eslint-disable */')
      lines.push('/* tslint:disable */')
      lines.push('export const noop = () => {}') // Always export something

      let f = _path
      if (f.endsWith('-sidecar.ts') || f.endsWith('-sidecar.tsx')) {
        // Don't scan indexes
        return
      }
      if (f.endsWith('.d.ts')) {
        // Skip d.ts files
        return
      }
      if (
        f.indexOf('.spec.') !== -1 ||
        f.indexOf('.test.') !== -1 ||
        f.indexOf('.e2e.') !== -1
      ) {
        // Test files
        return
      }

      let basename = path.basename(f)
      let last = basename.lastIndexOf('.')
      let filename = basename.substring(0, last)

      if (doesFileHaveNamedExport(f, filename)) {
        // Named exports
        lines.push(`export * from './${filename}'`)
      } else {
        // Group and re-export
        lines.push(`import * as ${filename} from './${filename}'`)
        lines.push(`export { ${filename} }`)
      }

      let ext = path.extname(_path)
      let pathWithoutExt = _path.slice(0, _path.length - ext.length)

      let indexFilename = pathWithoutExt + '-sidecar.' + options.extension

      // Write the file
      let skip = false
      let newFileContents = lines.join('\n')
      if (fs.existsSync(indexFilename)) {
        let cur = fs.readFileSync(indexFilename, 'utf8')
        if (cur.startsWith('// barrel-rider:ignore')) {
          skip = true
        }
        if (cur === newFileContents) {
          skip = true
          skippedCount++
        }
      }
      if (!skip) {
        rebuiltCount++
        fs.writeFileSync(indexFilename, newFileContents)
        rebuiltPaths.push(indexFilename)
      }
    })

    if (!options.quiet) {
      if (rebuiltCount) {
        console.log(
          'barrel-rider rebuilt',
          rebuiltCount,
          'skipped',
          skippedCount,
        )
        if (rebuiltPaths.length === 1) {
          console.log(`(${rebuiltPaths[0]})`)
        }
      }
    }
    indexesToRebuild = [] // Reset
  }
  const rebuildIndexesThrottled = l.debounce(rebuildIndexes, 2000)

  function doesFileHaveNamedExport(_path, filename: string) {
    if (filename.indexOf('index') !== -1) {
      return false
    }

    let regex = new RegExp(
      `\\s*export\\s+(async\\s+)?(const|function|interface)\\s+(${filename})(\\s|\())`,
    )
    let regex2 = new RegExp(`\\s*export\\s+{\\s+(${filename})\\s+.*}`)

    let f = fs.readFileSync(_path, { encoding: 'utf8' })

    return regex.test(f) || regex2.test(f)
  }

  const watchDirecories = []
  l.forEach(options.src, (c) => {
    if (options.watch) {
      const watchDirectory = path.join(cwd, c)
      //const watchDirectoryGlob = watchDirectory + '/**/*(.ts|.tsx)'
      let watchDirectoryGlob = path.join(watchDirectory, '/**/*.(ts|tsx)')

      if (/^win/.test(process.platform)) {
        watchDirectoryGlob = watchDirectoryGlob.replace(/\\/g, '/')
      }

      watchDirecories.push(watchDirectoryGlob)
      // rebuildIndex(watchDirectory)
      console.log('watching: ', watchDirectoryGlob)
      // if (options.verbose) {
      //   console.log('watching: ', watchDirectoryGlob)
      // }
    } else {
      // TODO work without watch mode
      // glob(c + '/*.@(ts|tsx)')
    }
  })
  if (options.watch) {
    let watcher = watch(watchDirecories, {
      ignoreInitial: false,
    })
    watcher.on('add', (_path: string, stat) => {
      rebuildIndex(_path)
    })
    watcher.on('change', (_path, stat) => {
      rebuildIndex(_path)
    })
    watcher.on('delete', (_path, stat) => {
      rebuildIndex(_path)
    })
  }

  function _watch() {
    const app = express()
    app.use(cors())
    app.use(bodyParser.json())

    const port = options.port || 5000
    app.get('/', (req, res) => res.send('Barreler tool'))
    app.listen(port, () => console.log(`Barreler listening on port ${port}!`))
  }

  if (options.watch) {
    _watch()
  }
}
run()
